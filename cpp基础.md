# cpp基础

## 类（class）

类的属性和方法声明一般放在头文件中，定义在cpp文件中放置（科大刘利刚老师的代码是这样写的）

### 构造函数（constructor）

1. 一个类可以设置多个构造函数（函数重载，适应不同的初始化需求）		

    ```cpp
    * Array();//默认构造函数
    * Array(int nSize, double dValue = 0);//带两个参数的构造函数，其中第二个参数有一个默认值
    ```

	创建类的对象实例时使用下列代码：

    ```cpp
    Array arr1; // 调用无参数的构造函数
    Array arr2(10, 5.0); // 调用带参数的构造函数
    Array arr3(5); // 也会调用带参数的构造函数，因为第二个参数有默认值
    ```

2. 构造函数还可以使用初始化列表来初始化字段，例：

    ```cpp
    Line::Line( double len): length(len)
    {
        cout << "Object is being created, length = " << len << endl;
    }
    ```

	上面的语法等同于：

    ```cpp
    Line::Line( double len)
    {
        length = len;
        cout << "Object is being created, length = " << len << endl;
    }
    ```

	也可以初始化多个字段：

    ```cpp
    C::C( double a, double b, double c): X(a), Y(b), Z(c)
    {
      ....
    }
    ```

	例如：在链表结构体的构建过程中

    ```cpp
    // 单链表
    struct ListNode {
        int val;  // 节点上存储的元素
        ListNode *next;  // 指向下一个节点的指针
        ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数，将x的值赋给val，next指针为空
    };
    
    int main()
    {
        ListNode* head = new ListNode(5)//使用自己的构造函函数初始化头结点
    
        ListNode* head = new ListNode()//使用默认构造函数初始化头结点
        head->val = 5;
    }
    ```

### 内联函数（inline）

1. 如果一个函数是内联的，编译时，会把该函数的代码副本放置在每个调用该函数的地方。而普通函数是在运行时调用

2. 类内的方法（函数）是默认内联的，但是编译器自身的优化可能不内联此函数（函数过于复杂的时候）

3. 强制内联加上inline关键字

4. 函数短小，并且用的多时使用内联。复杂的函数不要内联（适得其反）；递归函数不要使用内联

5. 声明方式：

    ```cpp
    inline return_type FunctionName(parameter list){};
    ```

	**优点：**避免压栈出栈，提高效率；减少函数调用开销；代码可读性增加（内联函数直接放在类声明中，方便理解和维护）

### 虚函数（virtual）

   代码示例：
```cpp
class Entity //基类
{
public:
virtual string GetName() //基类中的GetName函数定义为虚函数
{
return "Entity";
}
};
class Player : public Entity
{
private:
string m_Name;
public:
Player(const string &name) : m_Name(name) {}
string GetName() override { return m_Name; } //重新定义GetName函数以实现多态
};
```

1. 在基类中使用virtual关键字声明函数，在派生类重新定义这个函数时，告诉编译器不要**静态链接**到基类中的该函数，以实现**多态**。

	* 目的：**在派生类中重新定义与基类同名的函数，可以通过基类指针或引用访问基类和派生类的同名函数**

2. 实现虚函数的步骤：

    ```cpp
    *定义基类，声明基类函数为virtual
    *定义派生类（继承自基类），派生类实现了定义在基类的virtual函数
    *声明基类指针，并指向派生类，调用virtual函数，此时虽然是基类指针，但调用了派生类实现的virtual函数
    ```

3. **纯虚函数**：在基类中定义的方法没有具体的实现，此时用到纯虚函数
	* 带有纯虚函数的类为抽象类，不能直接生成对象。
	* **优点**：防止派生类忘记实现虚函数，纯虚函数使得派生类必须实现基类的虚函数
    ```cpp
    virtual string eat() = 0; //在基类中，告诉编译器，函数没有主体。
    ```

4. 虚函数的使用说明：

    * 在基类加上virtual关键字，在派生类重新定义时加上override，**来保证确实重新定义的函数原型与基类的函数原型（函数类型，函数名，参数个数，参数类型顺序）完全一样**

    * 派生类重新定义时可以不写关键字virtual，最好加上override保证正确性

    * 如果在派生类中没有重新定义虚函数，则**公有派生类继承基类的虚函数**

    * 虚函数不能是**友元函数**和**静态成员函数**

    * 使用**对象名和点运算符调用虚函数是在编译时进行**的，是静态编译，没有利用虚函数的特性。只有通过**基类指针访问虚函数**时才能获得运行时的多态性。

    ```cpp
    Player p("zhou"); //定义一个派生类对象p
    Entity *e = &p; //定义一个基类指针e指向对象p
    cout << e->GetName() << endl; //访问虚函数（实际输出是派生类中的虚函数）
    ```

5. 虚析构函数

   一个类中如果有虚函数，则默认的析构函数也是虚函数，例如：

    ```cpp
    Entity *e = new Player();
    delete e;
    ```

	* 上述定义了一个指向派生类的基类指针，删除指针释放内存时，会首先调用派生类Player的析构函数，再调用基类Entity的析构函数。

	* 定义的类中有虚函数时，如果自己定义析构函数，一定要定义为虚析构函数。防止释放了基类的指针内存，而没有释放派生类的空间，造成内存泄漏。

6. 虚函数表（V-Table）

   由编译器生成，一个类有虚函数，就会生成一个四个字节的虚函数表指针，指向虚函数表。存储在对象实例最前面的位置。（虚函数表用来存放虚函数地址）

*我对虚函数的一些理解*：想要根据特定的对象选择函数的实现功能（但是函数名和基类相同（为了更好地适用于对象，比如：对于基类是一个动物类，派生类猫类，都有“吃”这个方法（函数），但是我想在猫类中指定“吃鱼”这个方法，但是方法名仍然设为“吃”，这时候就需要虚函数））称为**动态链接**。

